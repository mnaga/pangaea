/*global Util */

/**
 * Connection event flow
 *
 * Connection Lifecycle:
 *    - 'start' event occurs on the Connection object
 *    - One of:
 *      - Success flow is entered if cached data is provided by a handler
 *          An error by the callback at this phase will cause a cache-error event on the Connection
 *          object.
 *      - Error flow is entered if handler marks the request as in error prior to connecting
 *      - XHR request is made if the start handlers do not abort via error or cache response
 *
 * Success:
 *    - On success 'data' event is triggered on the Connection object.
 *        At this point event handlers may change the status field of the event data object
 *        to a value other than 'success' to trigger the error handling logic.
 *    - The sync or ajax success handler is triggered
 *
 * Error:
 *    - On error from the ajax layer or from success handler the 'error' event will be triggered
 *        on the Connection object. If a handler would like to prevent the final error handling
 *        stage from occurring then the error callback method on the event may be overriden.
 *
 *    - If not disabled then the global or instance specific `errorHandler` instance is called
 *    - Executes error callback defined in options object, if any.
 *
 * Complete:
 *  Executed after success or error flows regardless of the exact path.
 *    - Triggers 'end' event on Connection
 *    - Execute complete callback defined in options object, if any.
 *
 *
 * Error Handling:
 *  Generic error handling is done primarily through generic events. These are:
 *    exports: fatal-error(status, errorInfo)
 *    dataObject: error(dataObject, status, errorInfo)
 */
var Connection = exports.Connection = _.extend({
  /**
   * Known status/error cases.
   *
   * Note that this list is augmented by the errors generated by the zepto ajax layer.
   */
  SUCCESS: 'success',

  // Zepto Stack Errors
  HTTP_ERROR: 'error',
  PARSER_ERROR: 'parsererror',
  TIMEOUT_ERROR: 'timeout',

  CONNECTION_ERROR: 'connection',
  MAINTENANCE_ERROR: 'maintenace-error',
  SERVER_ERROR: 'server-error',
  UNKNOWN_ERROR: 'unknown-error',

  SESSION_EXPIRED: 'session-expired',
  NOT_FOUND_ERROR: 'not-found-error',

  /**
   * Generic wrapper for ajax calls. Manages generic error handling as well as provides
   * helpful defaults.
   *
   * May be called with context of model or collection
   */
  ajax: function(options) {
    options = _.clone(options);
    if (!applyConnectionOptions(options, this)) {
      return;
    }

    $.ajax(options);
  },

  /**
   * Updated backbone sync method. Provides generalized caching and error handling
   */
  sync: function(method, dataObject, options) {
    options = _.clone(options);
    if (dataObject.syncOptions) {
      dataObject.syncOptions(method, options);
    }
    options.url = options.url || Util.valueOf(dataObject.url, dataObject);
    options.syncMethod = method;

    if (!applyConnectionOptions(options, dataObject)) {
      return;
    }

    return Thorax.sync.call(this, method, dataObject, options);
  },

  errorHandler: function(event) {
    var dataObject = event.dataObject;

    if (!dataObject._aborted && Connection.isFatal(event)) {
      exports.trigger('fatal-error', event.status, event.errorInfo);
    }
    dataObject.trigger('error', dataObject, event.status, event.errorInfo);
  },
  isFatal: function(event) {
    return !event.options.ignoreErrors;
  },

  /**
   * Allows for explicit cache invalidation of a particular set of urls, based on prefix.
   *
   * Connection plugins that implement caching should monitor for the invalidate event and
   * invalidate any stored caches when seen.
   */
  invalidate: function(prefix, options) {
    // Match the event pattern used by the other events to maximize code reuse.
    var event = {
      options: _.defaults({url: prefix || ''}, options)
    };
    Connection.trigger('invalidate', event);
  },

  /*
   * Prevents out of band data requests from overwriting legitimate data.
   *
   * This should be used in conjunction with the resetQueue option on fetch
   * to ensure that the most recent data is displayed after configuration
   * changes occur on the data object.
   *
   * Ex:
   *     sync: Phoenix.Connection.boundSync(['sortField'], Phoenix.PagedCollection.prototype.sync),
   */
  boundSync: function(fields, $super) {
    return function(method, dataObj, options) {
      function bindToFields(callback) {
        return function() {
          var different = _.any(fields, function(field) {
            return original[field] !== dataObj[field];
          });
          if (!different) {
            callback.apply(this, arguments);
          }
        };
      }

      // Collect the current watch values
      var original = {};
      _.each(fields, function(field) {
        original[field] = dataObj[field];
      });

      options.success = bindToFields(options.success);
      options.error = bindToFields(options.error);
      return $super.apply(this, arguments);
    };
  },


  loadImage: function(src, alt, success, failure) {
    if (!src) {
      success && success();
      return;
    }

    var img;
    if (_.isElement(src)) {
      img = src;
      src = img.src;

      if (img.complete) {
        success && success();
        return;
      }
    } else {
      img = new Image();
      img.alt = alt;
    }
    img.onload = function() {
      try {
        // Kill the loading indicator to prevent dupes and improve GC
        img.onerror = img.onload = undefined;

        success && success(img);
      } catch (err) {
        Phoenix.trackCatch('loadImage ' + src, err);
      }
    };
    img.onerror = function() {
      img.onerror = img.onload = undefined;

      Phoenix.trackError('image-error', src);
      failure && failure();
    };
    img.src = src;
    return img;
  }
}, Backbone.Events);

//***************
// Setup helpers
//***************

function applyConnectionOptions(options, dataObject) {
  options.dataType = options.dataType || 'json';
  if (dataObject.secureUrl) {
    options.secure = true;
  }

  var event = {
    options: options,
    originalUrl: options.url,
    dataObject: dataObject,

    success: options.success,
    error: options.error,
    complete: options.complete
  };

  // Apply one layer of indirection so callbacks may modify this
  function callback(field) {
    return function() {
      var callback = event[field];
      if (callback) {
        callback.apply(this, arguments);
      }
    };
  }
  var success = callback('success'),
      error = callback('error'),
      complete = callback('complete');

  Connection.trigger('start', event);

  // AJAX Event handling
  options.success = wrapAjaxCallback('data', event, function() {
    if (!event.errorInfo && event.status === Connection.SUCCESS) {
      success.call(this, event.responseData, event.status, event.xhr);
    } else {
      options.error.call(this, event.xhr, event.status, event.errorInfo);
    }
  });
  options.error = wrapAjaxCallback('error', event, function() {
    if (!options.ignoreErrors) {
      (dataObject.errorHandler || Connection.errorHandler).call(dataObject, event);
    }
    error.call(this, event.xhr, event.status, event.errorInfo);
  });
  options.complete = wrapAjaxCallback('end', event, complete);

  // If we have cached data then push it out
  if (event.responseData) {
    // WARN : Not passing the xhr object. This will break for any objects that need that
    try {
      success(event.responseData, Connection.SUCCESS);
      complete();

      // Explicitly return nothing in this case to prevent further processing
      return;
    } catch (err) {
      Connection.trigger('cache-error', event);
      exports.trackCatch('cachedData ' + options.url, err);
    }
  } else if (event.status && event.status !== Connection.SUCCESS) {
    // Shortcircuit the error handling
    options.error.call(this, event.xhr, event.status, event.errorInfo);
    options.complete.call(this, event.xhr, event.status, event);
    return;
  }

  return options;
}
function wrapAjaxCallback(eventName, event, callback) {
  return function(data, status, xhr) {
    try {
      if (data && data.onreadystatechange) {
        // Support error and complete callback signatures
        event.errorInfo = event.errorInfo || xhr;
        event.xhr = event.xhr || data;
      } else {
        // Success signature
        event.responseData = data;
        event.xhr = xhr;
      }
      event.status = event.status || status;

      Connection.trigger(eventName, event);

      // Match the error and complete signature so we can pass directly. Success will
      // do custom handling
      callback.call(this, event.xhr, event.status, event.errorInfo);
    } catch (err) {
      event.errorInfo = err;
      Phoenix.trackCatch('ajax.' + event + ' ' + event.options.url, err);
    }
  };
}

// Work around Backbone's ever changing API....
// Note that this does not implement the majority of the backbone features as we only use this for
// GET operations.
//
// See https://github.com/documentcloud/backbone/issues/2031 for further info.
Backbone.sync = function(method, model, options) {
  options = options || {};

  // Default JSON-request options.
  var params = {type: 'GET', dataType: 'json'};

  // Ensure that we have a URL.
  if (!options.url) {
    params.url = _.result(model, 'url');
    if (!params.url) {
      throw new Error('A "url" property or function must be specified');
    }
  }

  // Make the request, allowing the user to override any Ajax options.
  var xhr = $.ajax(_.extend(params, options));
  model.trigger('request', model, xhr, options);
  return xhr;
};

Connection.on('end', function(event) {
  if (!event.errorInfo && event.options.invalidate) {
    // If the call needs to blow some things away do it
    var prefix = event.dataObject.invalidateUrl;
    if (_.isFunction(prefix)) {
      prefix = prefix.call(event.dataObject, event);
    }

    if (prefix) {
      // Making best guest at what the options mapping should be and reusing the ones
      // that are currently in use
      Connection.invalidate(prefix, event.options);
    }
  }
});
